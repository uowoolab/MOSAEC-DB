#!/usr/bin/env python3
import os
import glob
import json
import argparse
import warnings

import numpy as np

from datetime import date
from pathlib import Path
from collections import defaultdict

from pymatgen.io.cif import CifParser


# compare floats within a certain tolerance
def floats_equal(a, b, tol=0.01):
    a = float(a)
    b = float(b)
    return abs(a - b) <= (min(abs(a), abs(b)) * tol)


# read in partial atomic charges stored in JSON file
def read_pac_json(json_name):
    with open(json_name, "r") as jsonr:
        pac_dict = json.load(jsonr)
    return pac_dict


# iterate
def assign_partial_atomic_charge(
    cifs_path, repeat_json, dst_path=None, pac_type="REPEAT"
):
    # set defaults for arguments
    if dst_path is None:
        dst_path = cifs_path.parent
    else:
        dst_path = Path(dst_path)
    # get saved json charge dict
    charge_dict = read_pac_json(repeat_json)
    # find all cifs to be processed
    cifs = glob.glob(f"{cifs_path}/*.cif", recursive=False)
    #
    for cif_path in cifs:
        # check if charges available in stored json
        if os.path.basename(cif_path) in charge_dict.keys():
            charge_dict_i = charge_dict[os.path.basename(cif_path)]
        else:
            print(f"{cif_path} | ERROR | {pac_type} not stored")
            continue
        # parse cif using pymatgen
        cif_path = Path(cif_path)
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            try:
                cif_struct = CifParser(cif_path).get_structures(primitive=False).pop()
            except ValueError:
                print(f"{cif_path} | ERROR | EMPTY cif")
                continue

        # compare number of atoms between CIF and saved JSON
        # if len(cif_struct) != len(charge_dict_i):
        json_num_atoms = sum(
            [len(v) for k, v in charge_dict_i.items() if k != "rand_key"]
        )
        if len(cif_struct) != json_num_atoms:
            print(
                cif_path,
                " | ERROR | Different number of atoms in CIF (",
                len(cif_struct),
                ") and JSON (",
                json_num_atoms,
                ").",
            )
            continue

        # Get atomic symbols and fractional coordinates for all atoms
        symbols = [atom.specie.symbol for atom in cif_struct]
        frac_xyz = np.around([atom.frac_coords for atom in cif_struct], decimals=6)
        frac_xyz[frac_xyz == 0.0] = 0.0

        # Reassign labels for all atoms
        labels = []
        label_counter = {element: 0 for element in set(symbols)}
        for symbol in symbols:
            label_counter[symbol] += 1
            labels.append(f"{symbol}{label_counter[symbol]}")

        # Create preambles for the new CIF file
        if pac_type == "REPEAT":
            new_cif = "# Generated by REPEAT Assigner based on pymatgen\n"
        else:
            new_cif = "# Charges generated by MEPO-ML\n"
        #
        new_cif += f"data_{cif_path.name.replace('.cif', '')}\n"
        new_cif += "_audit_creation_date              "
        new_cif += date.today().strftime("%Y-%m-%d") + "\n"
        #
        if pac_type == "REPEAT":
            new_cif += "_audit_creation_method            REPEAT_Assigner\n"
        else:
            new_cif += "_audit_creation_method            MEPO-ML\n"

        # Create cell info for the new CIF file
        new_cif += f"_cell_length_a                    {cif_struct.lattice.a:.6f}\n"
        new_cif += f"_cell_length_b                    {cif_struct.lattice.b:.6f}\n"
        new_cif += f"_cell_length_c                    {cif_struct.lattice.c:.6f}\n"
        new_cif += f"_cell_angle_alpha                 {cif_struct.lattice.alpha:.6f}\n"
        new_cif += f"_cell_angle_beta                  {cif_struct.lattice.beta:.6f}\n"
        new_cif += f"_cell_angle_gamma                 {cif_struct.lattice.gamma:.6f}\n"
        new_cif += (
            f"_cell_volume                      {cif_struct.lattice.volume:.6f}\n"
        )

        # [ASSUMED P1] Create symmetry info for the new CIF file
        new_cif += "_symmetry_space_group_name_H-M    P1\n"
        new_cif += "_symmetry_Int_Tables_number       1\n"
        new_cif += "loop_\n"
        new_cif += "    _symmetry_equiv_pos_site_id\n"
        new_cif += "    _symmetry_equiv_pos_as_xyz\n"
        new_cif += "    1  x,y,z\n"

        # Create atom info for the new CIF file
        new_cif += "loop_\n"
        new_cif += "    _atom_site_type_symbol\n"
        new_cif += "    _atom_site_label\n"
        new_cif += "    _atom_site_fract_x\n"
        new_cif += "    _atom_site_fract_y\n"
        new_cif += "    _atom_site_fract_z\n"
        new_cif += "    _atom_type_partial_charge\n"

        # Adjust widths for the symbols and labels column
        symbol_width = len(max(symbols, key=len))
        label_width = len(max(labels, key=len))

        # flags to gauge if cif is consistent with prior entry
        # required for changes in atom ordering with different version of
        # dependencies e.g., pymatgen

        # block writing if error is encountered
        write_cif = True
        # whether the ordering of the sites/labels e.g., C1, C2, C3...
        # equals past ordering (potential for different CifParsing behaviour)
        label_order_issue = False
        # dict mapping the current:past cif atom labels
        label_mismatch = defaultdict(str)
        # Loop over all atoms and create info line for each of
        rand_num = np.array(charge_dict_i["rand_key"])
        # track number of matches
        try:
            match_count = 0
            for j, (symbol, label, frac) in enumerate(zip(symbols, labels, frac_xyz)):
                # prev_line = charge_dict_i[str(j)]
                pac_list_Z = charge_dict_i[symbol]
                # iterate over all sites with shared atomic symbol to find match
                # match_ind = None
                # frac_sum = sum(frac)
                frac_sum = sum(frac * rand_num)
                for k, site_dict in enumerate(pac_list_Z):
                    # check X
                    if not floats_equal(frac[0], site_dict["x"]):
                        continue
                    # check sum
                    # if not floats_equal(frac_sum, site_dict["sum"]):
                    if not floats_equal(frac_sum, site_dict["sum_rand"]):
                        continue
                    # check label
                    if label != site_dict["label"]:
                        label_mismatch[label] = site_dict["label"]
                        label_order_issue = True
                    # select index that passes all checks
                    match_ind = k
                    break
                # cleanup
                if match_ind != None:
                    match_count += 1
                    charge = pac_list_Z[match_ind]["charge"]
                    # write line
                    new_cif += f"    {symbol:{symbol_width}}  {label:{label_width}}  "
                    new_cif += "{:.6f}  {:.6f}  {:.6f}  ".format(*frac) + f"{charge}\n"
                else:
                    print(
                        f"{cif_path} | ERROR | Did not find a matching atom site ... \n",
                        label,
                    )
                    print(symbol, label, frac, frac_sum)
                    print(pac_list_Z)
                    write_cif = False
                    break
        except Exception as e:
            print(f"{cif_path} | ERROR | Issue assigning Charge", e)
            continue

        if label_order_issue:
            print(
                f"{cif_path} | WARNING | Label mismatch ... \n",
                dict(label_mismatch),
            )
        if write_cif & (match_count == len(cif_struct)):
            # Write the new CIF
            dst_path.joinpath(
                cif_path.name.replace(".cif", f"_{pac_type}.cif")
            ).write_text(new_cif)


if __name__ == "__main__":
    code_desc = "Assigning partial atomic charges (PAC e.g., REPEAT, MEPO-ML) to a MOSAEC-DB CIF."
    ap = argparse.ArgumentParser(description=code_desc)
    ap.add_argument("cif_path", type=str, help="path to the structure files (cif).")
    ap.add_argument(
        "-o",
        "--outdir",
        type=str,
        metavar="OUTPUT_DIR",
        help="output directory for structure files with PACs included.",
    )
    ap.add_argument(
        "-r",
        "--repeat_json",
        type=str,
        metavar="REPEAT_JSON",
        help="Explicitly provide the name of the REPEAT output file.",
    )
    ap.add_argument(
        "--pac_type",
        type=str,
        default="REPEAT",
        metavar="PAC_TYPE",
        choices=["REPEAT", "MEPOML"],
    )
    args = ap.parse_args()
    assign_partial_atomic_charge(args.cif, args.repeat_json, args.outdir, args.pac_type)

